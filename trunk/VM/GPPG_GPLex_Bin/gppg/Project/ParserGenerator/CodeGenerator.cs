// Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2007
// (see accompanying GPPGcopyright.rtf)

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;


namespace gpcc
{
    public class CodeGenerator
    {
		public Grammar grammar;

        public void Generate(List<State> states, Grammar grammar)
        {
            StreamWriter tWrtr = null;
            StreamWriter sWrtr = null;
            StreamWriter cWrtr = null;
            TextWriter   save = Console.Out;

			this.grammar = grammar;
            if (grammar.OutFName != null)
            {
                try
                {
                    FileStream fStrm = new FileStream(grammar.OutFName, FileMode.Create);
                    sWrtr = new StreamWriter(fStrm);
                    Console.WriteLine("GPPG: sending output to {0}", grammar.OutFName);
                    Console.SetOut(sWrtr);
                }
                catch (IOException x)
                {
                    Console.Error.WriteLine("GPPG: Error. File redirect failed");
                    Console.Error.WriteLine(x.Message);
                    Console.Error.WriteLine("GPPG: Terminating ...");
                    Environment.Exit(1);
                }
            }

            if (grammar.TokFName != null) // generate token list file
            {
                try
                {
                    FileStream fStrm = new FileStream(grammar.TokFName, FileMode.Create);
                    tWrtr = new StreamWriter(fStrm);
                    tWrtr.WriteLine("// Symbolic tokens for parser for grammar file \"{0}\"", grammar.InputFName);
                }
                catch (IOException x)
                {
                    Console.Error.WriteLine("GPPG: Error. Failed to create token namelist file");
                    Console.Error.WriteLine(x.Message);
                    tWrtr = null;
                }
            }

            if (grammar.DiagFName != null) // generate conflict list file
            {
                try
                {
                    FileStream cStrm = new FileStream(grammar.DiagFName, FileMode.Create);
                    cWrtr = new StreamWriter(cStrm);
                    cWrtr.WriteLine("// Parser Conflict Information for grammar file \"{0}\"", grammar.InputFName);
                    cWrtr.WriteLine();
                }
                catch (IOException x)
                {
                    Console.Error.WriteLine("GPPG: Error. Failed to create conflict information file");
                    Console.Error.WriteLine(x.Message);
                    cWrtr = null;
                }
            }

            GenerateCopyright();

            GenerateUsingHeader();

            if (grammar.Namespace != null)
            {
                Console.WriteLine("namespace {0}", grammar.Namespace);
                Console.WriteLine('{');
            }

			GenerateTokens(grammar.terminals, tWrtr);
            grammar.ReportConflicts(cWrtr);

            GenerateClassHeader(grammar.ParserName);
            InsertCode(grammar.prologCode);
            GenerateInitializeMethod(states, grammar.productions, grammar.nonTerminals);
            GenerateActionMethod(grammar.productions);
            GenerateToStringMethod();
            InsertCode(grammar.epilogCode);
            GenerateClassFooter();

            if (grammar.Namespace != null)
                Console.WriteLine('}');

            if (tWrtr != null)
            {
                tWrtr.WriteLine("// End symbolic tokens for parser");
                tWrtr.Close(); // Close the optional token name stream
            }

            if (cWrtr != null)
            {
                cWrtr.WriteLine("// End conflict information for parser");
                cWrtr.Close(); // Close the optional token name stream
            }

            if (sWrtr != null)
            {
                Console.SetOut(save);
                sWrtr.Close();
            }
        }


		private void GenerateCopyright()
		{
            Console.WriteLine("// This code was generated by the Gardens Point Parser Generator");
            Console.WriteLine("// Copyright (c) Wayne Kelly, QUT 2005-2007");
            Console.WriteLine("// (see accompanying GPPGcopyright.rtf)");
            Console.WriteLine();
            Console.WriteLine("// GPPG version " + GPCG.versionInfo);
            Console.Write("// options:");
            if (GPCG.LINES) Console.Write(" lines"); else Console.Write(" no-lines");
            if (GPCG.REPORT) Console.Write(" report");
            if (GPCG.CONFLICTS) Console.Write(" conflicts");
            if (GPCG.DEFINES) Console.Write(" gplex");
            if (GPCG.BABEL) Console.Write(" babel");
            Console.WriteLine();
            
            Console.WriteLine();
            Console.WriteLine();
		}

		private void GenerateUsingHeader()
        {
            Console.WriteLine("using System;");
            Console.WriteLine("using System.Collections.Generic;");
            Console.WriteLine("using System.Text;");
            Console.WriteLine("using gppg;");
            foreach (string s in grammar.usingList)
                Console.WriteLine("using " + s + ";");
            Console.WriteLine();
        }

        private void GenerateTokens(Dictionary<string, Terminal> terminals, StreamWriter writer)
        {
            Console.Write("{0} enum {1} {{", grammar.Visibility, grammar.TokenName);
            bool first = true;
            foreach (Terminal terminal in terminals.Values)
                if (terminal.symbolic)
                {
                    if (!first)
                        Console.Write(",");
                    if (terminal.num % 8 == 1)
                    {
                        Console.WriteLine();
                        Console.Write("    ");
                    }
                    Console.Write("{0}={1}", terminal.ToString(), terminal.num);
                    first = false;
                    if (writer != null) 
                        writer.WriteLine("\t{0}.{1} /* {2} */", grammar.TokenName, terminal.ToString(), terminal.num);
                }

            Console.WriteLine("};");
            Console.WriteLine();
        }

		private void GenerateValueType()
		{
			if (grammar.unionType != null)
			{
                if (grammar.ValueTypeName == null)
                    // we have a "union" type declared, but no type name declared.
                    grammar.ValueTypeName = Grammar.DefaultValueTypeName;
				Console.WriteLine("{0}{1} struct {2}", 
                    grammar.Visibility, grammar.PartialMark, grammar.ValueTypeName);
				InsertCode(grammar.unionType);
			}
			else if (grammar.ValueTypeName == null)
				grammar.ValueTypeName = "int";
            // else we have a value type name declared, but no "union"
		}

        private void GenerateScannerBaseClass()
        {
            Console.WriteLine("// Abstract base class for GPLEX scanners");
            Console.WriteLine("public abstract class ScanBase : IScanner<{0},{1}> {2}",
                grammar.ValueTypeName, grammar.LocationTypeName, '{');
            Console.WriteLine("  private {0} __yylloc;", grammar.LocationTypeName);
            Console.Write("  public override {0} yylloc", grammar.LocationTypeName);
            Console.WriteLine(" {0} get {0} return __yylloc; {1} set {0} __yylloc = value; {1} {1}",'{', '}');
            if (GPCG.BABEL)
            {
                Console.WriteLine();
                Console.WriteLine("  protected abstract int CurrentSc { get; set; }");
                Console.WriteLine("  //");
                Console.WriteLine("  // Override the virtual EolState property if the scanner state is more");
                Console.WriteLine("  // complicated then a simple copy of the current start state ordinal");
                Console.WriteLine("  //");
                Console.WriteLine("  public virtual int EolState { get { return CurrentSc; } set { CurrentSc = value; } }");
                Console.WriteLine('}');
                Console.WriteLine();
                Console.WriteLine("// Interface class for 'colorizing' scanners");
                Console.WriteLine("public interface IColorScan {");
                Console.WriteLine("  void SetSource(string source, int offset);");
                Console.WriteLine("  int GetNext(ref int state, out int start, out int end);");
            }
            Console.WriteLine('}');
            Console.WriteLine();
        }

		private void GenerateClassHeader(string name)
        {
            GenerateValueType();
            if (GPCG.FORGPLEX) GenerateScannerBaseClass();
            Console.WriteLine("{2}{3} class {0}: ShiftReduceParser<{1}, {4}>", 
                name, grammar.ValueTypeName, grammar.Visibility, grammar.PartialMark, grammar.LocationTypeName);
            Console.WriteLine('{');
        }


        private void GenerateClassFooter()
        {
            Console.WriteLine('}');
        }


        private void GenerateInitializeMethod(
			List<State> states, 
			List<Production> productions, 
			Dictionary<string, NonTerminal> nonTerminals)
        {
            Console.WriteLine("  protected override void Initialize()");
            Console.WriteLine("  {");

			Console.WriteLine("    this.errToken = (int){0}.error;", grammar.TokenName);
            Console.WriteLine("    this.eofToken = (int){0}.EOF;", grammar.TokenName);
			
			Console.WriteLine();
			
			Console.WriteLine("    states=new State[{0}];", states.Count);
            int state_nr = 0;
            foreach (State state in states)
                GenerateState(state_nr++, state);
            
            Console.WriteLine();

			Console.WriteLine("    rules=new Rule[{0}];", productions.Count+1);
            foreach (Production production in productions)
                GenerateRule(production);

			Console.WriteLine();

			Console.Write("    nonTerminals = new string[] {\"\", ");
			int length = 37;
			foreach (NonTerminal nonTerminal in nonTerminals.Values)
			{
				string ss = String.Format("\"{0}\", ", nonTerminal.ToString());
				length += ss.Length;
				Console.Write(ss);
				if (length > 70)
				{
					Console.WriteLine();
					Console.Write("      ");
					length = 0;
				}
			}
			Console.WriteLine("};");

            Console.WriteLine("  }");

			Console.WriteLine();
        }


        private void GenerateState(int state_nr, State state)
        {
            Console.Write("    AddState({0},new State(", state_nr);

			int defaultAction = GetDefaultAction(state);
			if (defaultAction != 0)
				Console.Write(defaultAction);
            else
			{
				Console.Write("new int[]{");
                bool first = true;
                foreach (KeyValuePair<Terminal, ParserAction> transition in state.parseTable)
                {
                    if (!first)
                        Console.Write(",");
                    Console.Write("{0},{1}", transition.Key.num, transition.Value.ToNum());
                    first = false;
                }
                Console.Write('}');
            }

            if (state.nonTerminalTransitions.Count > 0)
            {
                Console.Write(",new int[]{");
                bool first = true;
                foreach (Transition transition in state.nonTerminalTransitions.Values)
                {
                    if (!first)
                        Console.Write(",");
                    Console.Write("{0},{1}", transition.A.num, transition.next.num);
                    first = false;
                }
                Console.Write('}');
            }

            Console.WriteLine("));");
        }


		private int GetDefaultAction(State state)
        {
			IEnumerator<ParserAction> enumerator = state.parseTable.Values.GetEnumerator();
			enumerator.MoveNext();
			int defaultAction = enumerator.Current.ToNum();

			if (defaultAction > 0) 
				return 0; // can't have default shift action

			foreach (KeyValuePair<Terminal, ParserAction> transition in state.parseTable)
				if (transition.Value.ToNum() != defaultAction)
					return 0;

			return defaultAction;
        }


        private void GenerateRule(Production production)
        {
            Console.Write("    rules[{0}]=new Rule({1}, new int[]{{", production.num, production.lhs.num);
			bool first = true;
			foreach (Symbol sym in production.rhs)
			{
				if (!first)
					Console.Write(",");
				else
					first = false;
				Console.Write("{0}", sym.num);
			}
			Console.WriteLine("});");
        }
        

        private void GenerateActionMethod(List<Production> productions)
        {
            Console.WriteLine("  protected override void DoAction(int action)");
            Console.WriteLine("  {");
            Console.WriteLine("    switch (action)");
            Console.WriteLine("    {");
            foreach(Production production in productions)
            {
				if (production.semanticAction != null)
                {
                    Console.WriteLine("      case {0}: // {1}", production.num, production.ToString());
					production.semanticAction.GenerateCode(this);
                    Console.WriteLine("        break;");
                }
            }
            Console.WriteLine("    }");
            Console.WriteLine("  }");
            Console.WriteLine();
        }


        private void GenerateToStringMethod()
        {
			Console.WriteLine("  protected override string TerminalToString(int terminal)");
			Console.WriteLine("  {");
			Console.WriteLine("    if (((Tokens)terminal).ToString() != terminal.ToString())");
			Console.WriteLine("      return ((Tokens)terminal).ToString();");
			Console.WriteLine("    else");
			Console.WriteLine("      return CharToString((char)terminal);");
			Console.WriteLine("  }");

            Console.WriteLine();
        }


        private void InsertCode(string code)
        {
            if (code != null)
            {
                StringReader reader = new StringReader(code);
                while (true)
                {
                    string line = reader.ReadLine();
                    if (line == null)
                        break;
                    Console.WriteLine("{0}", line);
                }
            }
        }
    }
}







